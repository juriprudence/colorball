<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Ring Runner</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            user-select: none;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            color: white;
            text-align: center;
            font-size: 18px;
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            color: white;
            text-align: center;
            font-size: 24px;
            background: rgba(255,0,0,0.8);
            padding: 30px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            display: none;
        }
        
        button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 10px;
            cursor: pointer;
            border-radius: 8px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background: #45a049;
        }
        
        #canvas {
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="ui">
            <div>Score: <span id="score">0</span></div>
        </div>
        
        <div id="instructions">
            <h2>ðŸŽ® 3D Ring Runner</h2>
            <p>Match your ball color with the ring segments!</p>
            <p><strong>Click or Tap</strong> to move forward</p>
            <p>Pass through matching colored segments only</p>
            <button onclick="startGame()">Start Game</button>
        </div>
        
        <div id="gameOver">
            <h2>ðŸ’¥ Game Over!</h2>
            <p>Final Score: <span id="finalScore">0</span></p>
            <button onclick="restartGame()">Play Again</button>
        </div>
        
        <canvas id="canvas"></canvas>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game variables
        let scene, camera, renderer, ball, rings = [], gameStarted = false, gameOver = false;
        let ballColor = 0xff0000, score = 0, ballSpeed = 0, maxSpeed = 0.3;
let cameraOffset = new THREE.Vector3(0, 5, 10);
        
        // Color palette
        const colors = [0xff0000, 0x00ff00, 0xffff00, 0x800000]; // red, green, yellow, dark red
        const colorNames = ['red', 'green', 'yellow', 'dark red'];
        
        // Initialize the game
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x667eea, 50, 200);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x667eea);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Create ball
            createBall();
            
            // Create initial rings
            createRings();
            
            // Event listeners
            document.addEventListener('click', onInteraction);
            document.addEventListener('touchstart', onInteraction);
            window.addEventListener('resize', onWindowResize);
            
            // Start render loop
            animate();
        }
        
        function createBall() {
            const ballGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            const ballMaterial = new THREE.MeshLambertMaterial({ color: ballColor });
            ball = new THREE.Mesh(ballGeometry, ballMaterial);
            ball.position.set(0, 0, 0);
            ball.castShadow = true;
            scene.add(ball);
        }
        
        function createRings() {
            rings = [];
            for (let i = 0; i < 10; i++) {
                createRing(i * 20 - 40);
            }
        }
        
        function createRing(zPosition) {
            const ringGroup = new THREE.Group();
            const radius = 4;
            const tube = 0.8;
            
            // Create 4 colored segments
            for (let i = 0; i < 4; i++) {
                const segmentGeometry = new THREE.TorusGeometry(radius, tube, 16, 16, Math.PI / 2);
                const segmentMaterial = new THREE.MeshLambertMaterial({ color: colors[i] });
                const segment = new THREE.Mesh(segmentGeometry, segmentMaterial);
                
                // Rotate each segment to create quarters
                segment.rotation.z = (Math.PI / 2) * i;
                segment.receiveShadow = true;
                segment.colorIndex = i;
                
                ringGroup.add(segment);
            }
            
            ringGroup.position.z = zPosition;
            ringGroup.rotationSpeed = (Math.random() - 0.5) * 0.08; // Increased speed
            
            scene.add(ringGroup);
            rings.push(ringGroup);
        }
        
        function onInteraction(event) {
            event.preventDefault();
            
            if (!gameStarted) return;
            if (gameOver) return;
            
            // Accelerate ball forward (faster)
            ballSpeed = Math.min(ballSpeed + 0.12, maxSpeed);
        }
        
        function startGame() {
        window.startGame = startGame;
            document.getElementById('instructions').style.display = 'none';
            gameStarted = true;
            gameOver = false;
            score = 0;
            ballSpeed = 0;
            
            // Reset ball position and color
            ball.position.set(0, 0, 0);
            changeBallColor();
            
            // Reset camera
            camera.position.set(0, 5, 10);
            camera.lookAt(ball.position);
            
            updateScore();
        }
        
        function restartGame() {
        window.restartGame = restartGame;
            document.getElementById('gameOver').style.display = 'none';
            
            // Reset rings
            rings.forEach(ring => scene.remove(ring));
            createRings();
            
            startGame();
        }
        
        function changeBallColor() {
            const randomIndex = Math.floor(Math.random() * colors.length);
            ballColor = colors[randomIndex];
            ball.material.color.setHex(ballColor);
        }
        
        function checkCollisions() {
            const ballPosition = ball.position;
            
            rings.forEach((ring, ringIndex) => {
                const ringPosition = ring.position;
                const distance = ballPosition.distanceTo(ringPosition);
                
                // Check if ball is passing through ring
                if (distance < 5 && Math.abs(ballPosition.z - ringPosition.z) < 1) {
                    // Determine which segment the ball is passing through
                    const angle = Math.atan2(ballPosition.y - ringPosition.y, ballPosition.x - ringPosition.x);
                    let normalizedAngle = ((angle + Math.PI) / (Math.PI * 2)) * 4;
                    normalizedAngle = Math.floor(normalizedAngle) % 4;
                    
                    // Adjust for ring rotation
                    const ringRotation = ring.rotation.z;
                    const rotationSegments = Math.floor(((ringRotation % (Math.PI * 2)) / (Math.PI * 2)) * 4);
                    const adjustedSegment = (normalizedAngle - rotationSegments + 4) % 4;
                    
                    const segmentColor = colors[adjustedSegment];
                    
                    // Check if colors match
                    if (ballColor === segmentColor) {
                        // Success! Remove this ring and add a new one
                        scene.remove(ring);
                        rings.splice(ringIndex, 1);
                        
                        // Add new ring further ahead
                        const furthestZ = Math.min(...rings.map(r => r.position.z)) - 20;
                        createRing(furthestZ);
                        
                        // Increase score and change ball color
                        score += 10;
                        changeBallColor();
                        updateScore();
                        
                        // Increase difficulty slightly
            maxSpeed = Math.min(maxSpeed + 0.02, 1.2);
                    } else {
                        // Game over!
                        endGame();
                    }
                }
            });
        }
        
        function endGame() {
            gameOver = true;
            ballSpeed = 0;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOver').style.display = 'block';
        }
        
        function updateScore() {
            document.getElementById('score').textContent = score;
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (gameStarted && !gameOver) {
                // Move ball forward
                ball.position.z -= ballSpeed;
                ballSpeed *= 0.98; // Natural deceleration
                
                // Rotate rings
                rings.forEach(ring => {
                    ring.rotation.z += ring.rotationSpeed;
                });
                
                // Update camera to follow ball
                const targetCameraPosition = ball.position.clone().add(cameraOffset);
                camera.position.lerp(targetCameraPosition, 0.1);
                camera.lookAt(ball.position);
                
                // Check collisions
                checkCollisions();
                
                // Remove rings that are too far behind
                rings.forEach((ring, index) => {
                    if (ring.position.z > ball.position.z + 20) {
                        scene.remove(ring);
                        rings.splice(index, 1);
                        
                        // Add new ring ahead
                        const furthestZ = Math.min(...rings.map(r => r.position.z)) - 20;
                        createRing(furthestZ);
                    }
                });
            }
            
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Initialize the game
        init();
    </script>
</body>
</html>